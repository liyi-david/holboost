"""
interpretations are used to handle the cases where we do not want to use low level concepts in Coq, Isabella, etc. for example,
natural numbers in Coq are represented by unary terms, e.g. 3 = (S (S (S O))). This may simplifies mathematical reasoning in Coq,
but it of course makes it harder to reason program properties. Instead, we want to use a natural number term as its interpretation.

"""
from .term import Term

import abc

class Interpretation(Term, metaclass=abc.ABCMeta):

    class InterpretationAbuse(Exception):
        pass

    def type(self, environment, context=[]) -> 'Term':
        return self.unfold().type(environment, context)

    def check(self, environment, context=[]):
        return self.unfold().check(environment, context)

    def __eq__(self, t):
        return self.unfold() == t

    def subterms(self):
        raise Interpretation.InterpretationAbuse

    def subterms_subst(self, subterms):
        raise Interpretation.InterpretationAbuse

    @abc.abstractmethod
    def unfold(self) -> 'Term':
        pass


class Provable(Term, metaclass=abc.ABCMeta):

    """
    A term is called provable, if and only if it is proved by some plugins in holboost. Since the tool
    is not as strict as Coq, precise proof term is not always required. Instead, a plugin may inherit the
    class `Provable` and invoke any proof checker they like.

    Holboost will try to reproduce the proof through running the proof obligations generated by get_proof_obligation
    """

    class ProvableTermAbuse(Exception):
        pass

    class ProofObligation:
        pass

    def __init__(self):
        self.proved_formula = None

    @abc.abstractmethod
    def get_proof_obligation(self) -> 'Provable.ProofObligation':
        pass

    def __eq__(self, t):
        raise Provable.ProvableTermAbuse

    def subterms(self):
        raise Provable.ProvableTermAbuse

    def subterms_subst(self):
        raise Provable.ProvableTermAbuse


class HolboostProvable(Provable, Interpretation):
    pass
