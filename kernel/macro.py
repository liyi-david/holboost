"""
interpretations are used to handle the cases where we do not want to use low level concepts in Coq, Isabella, etc. for example,
natural numbers in Coq are represented by unary terms, e.g. 3 = (S (S (S O))). This may simplifies mathematical reasoning in Coq,
but it of course makes it harder to reason program properties. Instead, we want to use a natural number term as its interpretation.

"""
from .term import Term

import re
import abc

class MacroFoldRule:

    class MacroFoldFailure(Exception): pass

    registered_rules = {}

    @classmethod
    def enable(cls, reg):
        filt = re.compile(reg)
        for c in cls.__subclasses__():
            fullpath = c.__module__ + "." + c.__name__
            if filt.match(fullpath):
                assert not isinstance(c, Macro), "MacroFoldRule and Macro cannot be inherited in the same class %s" % (
                        fullpath
                        )
                cls.registered_rules[fullpath] = c

    @classmethod
    def fold(cls, term):
        # a macro will not be folded
        if isinstance(term, Macro):
            return term

        # fold from the root
        for _, rule in cls.registered_rules.items():
            try:
                folden = rule.fold(term)
                if folden is not None:
                    return folden
            except cls.MacroFoldFailure as err:
                pass

        # fold the subterms
        try:
            folden_subterms = []
            for t in term.subterms():
                folden_subterms.append(t.fold())
                if folden_subterms[-1] is None:
                    return term

            return term.subterms_subst(folden_subterms)
        except cls.MacroFoldFailure:
            pass

        return term


class Macro(Term, metaclass=abc.ABCMeta):

    class MacroAbuse(Exception):
        pass

    @classmethod
    def macro_name(cls):
        assert type(cls) is not Macro, "cannot evaluate the name of Macro itself"
        return str(cls).split("'")[1]

    def type(self, environment=None) -> 'Term':
        return self.unfold(environment).type(environment)

    def check(self, environment=None):
        return self.unfold(environment).check(environment)

    def __eq__(self, t):
        if self is t:
            return True
        else:
            return self.unfold() == t

    def subterms(self):
        raise Macro.MacroAbuse

    def subterms_subst(self, subterms):
        raise Macro.MacroAbuse

    def fold(self):
        return MacroFoldRule.fold(self)

    @abc.abstractmethod
    def unfold(self, environment=None) -> 'Term':
        pass

    def to_json(self, environment=None):
        return {
                "node": "macro",
                "macro_name": self.macro_name(),
                }



    # ============================ operators ==================================

    # only type macros need to implement the following operators.

    def _eq(self, l, r):
        raise self.MacroAbuse("'=' is not implemented in the macro %s" % str(type(self)))

    def _neq(self, l, r):
        raise self.MacroAbuse("'!=' is not implemented in the macro %s" % str(type(self)))

    def _le(self, l, r):
        raise self.MacroAbuse("'<=' is not implemented in the macro %s" % str(type(self)))

    def _lt(self, l, r):
        raise self.MacroAbuse("'<' is not implemented in the macro %s" % str(type(self)))

    def _ge(self, l, r):
        return self._le(r, l)

    def _gt(self, l, r):
        return self._lt(r, l)


class ProofTerm(Term, metaclass=abc.ABCMeta):

    """
    A term is called provable, if and only if it is proved by some plugins in holboost. Since the tool
    is not as strict as Coq, precise proof term is not always required. Instead, a plugin may inherit the
    class `Provable` and invoke any proof checker they like.

    Holboost will try to reproduce the proof through running the proof obligations generated by get_proof_obligation
    """

    class ProofTermAbuse(Exception):
        pass

    class ProofObligation:
        pass

    def __init__(self):
        self.proved_formula = None

    @abc.abstractmethod
    def get_proof_obligation(self) -> 'Provable.ProofObligation':
        pass

    def type(self, environment=None, context=[]):
        return self.proved_formula

    def check(self, environment=None, context=[]):
        raise Provable.ProvableTermAbuse

    def __eq__(self, t):
        raise Provable.ProvableTermAbuse

    def subterms(self):
        raise Provable.ProvableTermAbuse

    def subterms_subst(self):
        raise Provable.ProvableTermAbuse
